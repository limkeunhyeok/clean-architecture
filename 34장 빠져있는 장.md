# Clean Architecture

## 06 세부사항

### 34장 빠져있는 장

#### 계층 기반 패키지

- 가장 단순한 첫번째 설계방식이고 전통적인 수평 계층형 아키텍처이다.
- 계층 기반 패키지란 기술적인 관점에서 해당 코드가 하는 일을 기반해 그 코드를 분할한다.
- 계층은 업무규칙으로 유사한 종류의 것들을 묶는 도구로 사용된다.
- 엄격한 계층형 아키텍처 경우 계층은 반드시 바로 아래 계층에만 의존해야 한다.

![계층 기반 패키지](https://wikidocs.net/images/page/167395/34.1.png)

- OrdersController: 웹기반 요청처리
- OrdersService: 주문 관련 업무규칙 정의
- OrdersServiceImpl: OrderService구현체
- OrdersRepository: 저장 정보에 접근하는 방법정의 인터페이스
- JdbcOrderRepository: OrdersRepository 구현체

##### 계층 기반 아키텍처 특징

- 처음 시작하기에 적합한 아키텍처이다.
- 엄청난 복잡함을 겪지 않고 무언가를 동작시켜주는 아주 빠른 방법이다.
- 소프트웨어가 커지고 복잡해 지면 모든 코드를 담기 부족하다고 깨닫게 되고, 더 잘게 모듈화 할지 고민하게 된다.
- 업무 도메인에 대해 아무것도 말해주지 않는다.

#### 기능 기반 패키지

- 기능 기반 패키지란 서로 연관된 기능, 도메인 개념, Aggregate Root(데이터 변경의 단위로 연관객체의 묶음)에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다.
- 모든 타입이 하나의 자바 패키지에 속하고, 패키지 이름은 그안에 담긴 개념을 반영해 짓는다.

![기능 기반 패키지](https://wikidocs.net/images/page/167395/34.2.png)

##### 기능 기반 패키지 특징

- 코드 상위 수준 구조가 업무 도메인에 대해 알려주게 된다.
- 주문 조회하기 유즈케이스 변경시 변경할 코드를 모두 찾는 작업이 쉬워진다.
  - 변경 해야할 코드가 모두 한 패키지에 담겨 있기 때문이다.
- 위 두가지 수평(계층 기반 패키지), 수직적 계층화(기능 기반 패키지) 지는 개발 차선책이다.

#### 포트와 어댑터

- 포트와 어댑터란 육각형 아키텍처로 경계, 컨트롤러, 엔티티 방식으로 접근한다.
  - 업무/도메인 코드와, 프레임워크나 데이터베이스 같은 기술적 세부구현과 독립적이며 분리된 아키텍처를 만들기 위한 구조이다.
- 내부(도메인)과 외부(인프라)로 구성된다.
- 내부 영역은 도메인 개념을 모두포함하나 외부는 UI, 데이터베이스, 서드파티 통합과 상호작용한다.
- 주요 규칙은 외부가 내부에 의존하며, 절대 그 반대로는 안 된다.

![포트와 어댑터](https://wikidocs.net/images/page/167395/34.4.png)

- OrdersRepository가 Orders라는 간단한 이름으로 바뀌었다.
- 도메인 주도 설계에서 ‘내부'에 존재하는 모든것의 이름은 반드시 ‘유비쿼터스 도메인 언어' 관점에서 기술하라고 한다.
  - 즉 도메인에 대해 논할때 우리는 '주문’에 대해 말하는 것이지 ‘주문 레파지터리'에 대해 말하는 것이 아니라는 것이다.

#### 컴포넌트 기반 패키지

- SOLID, REP, CCP, CRP 그외 다수 조언에는 동감하나 코드를 조직화 하는 방법에서 다른 선택지를 제시하고자 하는데 이 방법을 ‘컴포넌트 기반 패키지' 라고 부른다.
- 계층형 아키텍처 목적
  - 기능이 같은 코드끼리 서로 분리하는 것이다.
  - UI, 업무, 데이터 접근으로 분리하는데 각 계층은 일반적으로 자바 패키지에 해당한다.
  - 코드 접근성 관점에서 서비스 인터페이스 ,레파지터리 인터페이스를 접근하려면 public으로 열려 있어야 한다.
  - 엄격한 계층형 아키텍처에서 의존성 화살표는 항상 아래를 향해야 한다.(비순환 의존성 그래프를 유지하기 위해)
  - 몇몇 유스케이스에서는 Controller가 Service를 우회하고 있다. 이런 인접한 계층을 건너뛰는 일이 허용되는 것을 완화된 계층형 아키텍처라 부른다.

![완화된 계층 아키텍처](https://wikidocs.net/images/page/167395/34.5.png)

- 계층형 아키텍처에서 필요한 것들
  - 컨트롤러는 리포지터리에 직접 접근하면 안된다는 원칙
  - 원칙을 강제하고, 개발자를 신뢰함
  - 정적 분석도구를 통해 아키텍처 위반 사항이 없는지 검사
  - 아키텍처 원칙을 위반시 빌드가 실패하게 하는 방법
- 컴포넌트 기반 패키지는 큰 단위의 단일 컴포넌트와 관련된 모든 책임을 하나의 자바 패키지로 묶는데 주안점을 둔다. 또한 업무로직과 영속성 관련 코드를 하나로 묶는다.

![주문 조회하기 유스케이스](https://wikidocs.net/images/page/167395/34.6.png)

> 컴포넌트는 배포 단위이다. 컴포넌트는 시스템의 구성 요소로, 배포할수 있는 가장 작은 단위이다. 자바의 경우 jar파일이 컴포넌트 이다.

#### 구현 세부사항엔 항상 문제가 있다

> 모든 타입에서 public 지시자를 사용한다는 건 사용하는 프로그래밍 언어가 제공하는 캡슐화 관련 이점을 활용하지 않겠다는 뜻이다. 이로 인해 누군가가 구체적인 구현 클래스의 인스턴스를 직접 생성하는 코드를 작성하는 일을 절대 막을 수 없으니, 결국 지향하는 아키텍처 스타일을 위반하게 될 것이다.

#### 조직화 vs 캡슐화

> 자바 애플리케이션에서 모든 타입을 public으로 지정한다면, 패키지는 단순히 조직화를 위한 메커니즘으로 전략하여 캡슐화를 위한 메커니즘이 될 수 없다. Public 타입을 코드 베이스 어디에서도 사용할 수 있다면 패키지를 사용하는데 이점이 거의 없다. 사실상 패키지를 사용하지 않는 것과 같다. Public 지시자를 과용하면 이 장의 앞에서 제시한 네 가지 아키텍처 접근법은 본질적으로 완전히 같아진다.

![네 개의 아키텍처 접근법](https://velog.velcdn.com/images/rudaks94/post/2fa05a22-4b2e-4fea-bbaf-b3195057e32a/image.png)

1. 계층 기반 패키지 접근법에서 OrdersService와 OrdersRepository 인터페이스는 외부 패키지의 클래스로 부터 자신이 속한 패키지 내부로 들어오는 의존성이 존재하므로 public으로 선언되어야 한다. 반면 구현체 클래스 (OrdersServiceImpl과 JdbcOrdersRepository)는 더 제한적으로 선언할 수 있다. (패키지 protected)
2. 기능 기반 패키지 접근법에서는 OrdersController가 패키지로 들어올 수 있는 유일한 통로를 제공하므로 나머지는 모두 패키지 protected로 지정할 수 있다.
3. 포트와 어댑터 접근법의 경우 OrdersService와 Orders 인터페이스는 외부로 들어오는 의존성을 가지므로 public을 지정해야 한다.
4. 컴포넌트 기반 패키지 접근법에서는 컨트롤러에서 Orders Component 인터페이스로 향하는 의존성을 가지며 그 외의 모든 것은 패키지 protected로 지정할 수 있다. public 타입이 적으면 적을수록 필요한 의존성의 수도 적어진다.

![접근 지시자](https://velog.velcdn.com/images/rudaks94/post/6955528c-7531-4396-88e4-c1982ad64d26/image.png)

- 옅은 색은 더 제한적인 접근 지시자를 사용할 수 있다.

#### 다른 결합 분리 모드

- 프로그래밍 언어가 제공하는 방법 외에도 소스코드 의존성을 분리하는 방법은 존재할 수 있다.
  - OSGi같은 모듈 프레임워크나 자바 9에서 제공하는 새로운 모듈 시스템이 있다. 모듈 시스템을 제대로 사용하면 public 타입과 외부에 공표할 타입을 분리할 수 있다.
- 다른 선택지로는 소스 코드 수준에서 의존성을 분리하는 방법도 있다.
- 포트와 어댑터로 예로들면
  - 업무와 도메인용 소스 코드: OrderSerivce, OrdersServiceImpl, Orders
  - 웹용 소스 코드: OrdersController
  - 데이터 영속성용 소스 코드: JdbcOrderRepository
- 2, 3번 두 소스 트리는 컴파일 시점에서 업무와 도메인용 소스코드에 의존성을 가지며 업무와 도메인용 소스코드는 웹, 데이터영속성 코드에 대해 알지 못한다.
- 하지만 이는 너무 이상적인 해결책이다. 현실에서 소스코드를 이처럼 나누다 보면 성능, 복잡성, 유지보수 문제가 생기기 때문이다.
- 포트와 어댑터 접근법을 적용할 때는 이보다 간단한 방법을 사용하기도 하는데, 단순히 소스코드 트리를 두개만 만드는 것이다.
  - 도메인 코드('내부')
  - 인프라 코드('외부')
