# Clean Architecture

## 05 아키텍처

### 16장 독립성

좋은 아키텍처는 다음을 지원해야 한다.

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

#### 유스케이스

- 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
- 아키텍트의 최우선 관심사는 유스케이스이며, 아키텍처에서도 유스케이스가 최우선이다. 아키텍처는 반드시 유스케이스를 지원해야 한다.
- 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

#### 운영

- 시스템의 운영 지원 관점에서 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.
- 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬어질 것이다.

#### 개발

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

- 많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로를 방해하지 않도록 해야 한다.

#### 배포

- 아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 이때 목표는 즉각적인 배포(immediate deployment)다.
- 좋은 아키텍처는 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다.
- 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
- 이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.

#### 선택사항 열어놓기

- 좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사를 모두를 만족시킨다.
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

#### 계층 결합 분리

- 아키텍트는 시스템의 의도를 분명하게 알고 있기 때문에 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들을 분리하고, 동일한 이유로 변경되는 것들을 묶는다.
  - 즉, 시스템을 서로 결합 되지 않은 수평적인 계층으로 분리해야한다.

#### 유스케이스 결합 분리

- 유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙이 일부, 애플리케이션 독립적 업무 규칙의 일부, 그리고 데이터베이스 기능의 일부를 사용한다.
  - 따라서 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.
- 결합 분리를 위하여 시스템의 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 겹치지 않도록 한다.
- 서로 다른 이유로 변경되는 요소들의 결합을 분리한다.

#### 결합 분리 모드

- 유스케이스를 위해 수행하는 그 작업들(결합 분리)은 운영에도 도움이 된다.
- 운영 측면에서 이러한 장점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 한다.
  - 컴포넌트를 서비스 단계까지 나눌 수 도 있다.
- 실제로 서비스에 기반한 아키텍처를 흔히 서비스 지향 아키텍처(SOA)라고 부른다.

#### 개발 독립성

- 컴포넌트가 분리되면 개발 팀도 분리가 가능하다.

#### 배포 독립성

- 유스케이스와 계층의 결합이 분리되면 배포 측면에서고 고도의 유연성이 생긴다.
- 결합을 제대로 분리하면 운영 중인 시스템에서도 계층과 유스케이스 교체가 가능하다.

#### 중복

- 진짜 중복은 개발자라면 중복을 제거하거나 줄여야 한다.
- 우발적 중복은 진짜 중복이 아니다(서로 다른 속도와 다른 이유로 변경된다면 중복이 아니다).

#### 결합 분리 모드(다시)

- 계층과 유스케이스의 결합을 분리하는 방법은 다양하다. 소스 코드 수준에서 분리, 바이너리 코드(배포)수준에서, 그리고 실행 단위(서비스) 수준에서도 분리할 수 있다.
- 소스 수준 분리 모드: 소스 코드 모듈 사이의 의존성을 제어할 수 있다.
  - 모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신할 때 간단한 함수 호출을 사용한다.
  - 이러한 구조를 흔히 모노리틱 구조라고 부른다.
- 배포 수준 분리 모드: 배포 가능한 단위(라이브러리, jar 파일, DDL 등)들 사이의 의존성을 제어할 수 있다.
- 서비스 수준 분리 모드: 의존하는 수준을 데이터 구조 단위까지 낮출 수 있다.
  - 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.
  - 완전히 독립적이다.(서비스, 마이크로 서비스)
- 좋은 아키텍처는 결합 분리모드를 선택사항으로 남겨둔다.

> 즉, 모노리틱 구조에서 시작해서 마이크로서비스 수준까지 올라와도 원래 형태로 돌아갈 수 있어야 좋은 아키텍처라 할 수 있다.

#### 결론

- 시스템 결합 분리 모드는 시간이 지나면서 바뀌기 쉽기 때문에, 선택사항으로 남겨둬야한다.
