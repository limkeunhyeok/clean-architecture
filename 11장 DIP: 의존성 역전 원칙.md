# Clean Architecture

## 03 설계 원칙

### 11장 DIP: 의존성 역전 원칙

> 의존성 역전 원칙에서 말하는 유연성이 극대화된 시스템이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다. 의존하지 않도록 피하고자 하는 것은 변동성이 큰(volatile) 구체적인 요소이다.

#### 안정된 추상화

- 인터페이스는 구현체보다 변동성이 낮다.
- 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고 안정된 추상 인터페이스를 선호하는 아키텍처다.

**구체적인 코딩 실천법**

1. 변동성이 큰 구체 클래스를 참조하지 말라
2. 변동성이 큰 구체 클래스로부터 파생하지 말라
3. 구체 함수를 오버라이드 하지 말라
4. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라

#### 팩토리

- 변동성이 큰 객체를 생성할 때는 주의해야 한다.

![abstract factory](https://velog.velcdn.com/images/hellojihyoung/post/fbd5c783-5cfe-4ac4-bf2d-7a2eb2188d64/image.png)

- 위 그림에서 곡선은 시스템을 구체적인 것들로 부터 추상적인 것들을 분리한다.
- 소스 코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.
- 곡선은 시스템을 추상 컴포넌트, 구체 컴포넌트로 분리한다.
  - 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다.
  - 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 세부사항을 포함한다.
- 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. → 의존성 역전(Dependency Inversion)

#### 구체 컴포넌트

- 구체 컴포넌트에 구체적인 의존성이 없어야 하지만, DIP 위배를 모두 없앨 수는 없기 때문에 Main 함수에 구체 컴포넌트를 최소한 하나는 포함해준다.

#### 결론

- DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다.
- 의존성은 아키텍처 경계를 기준으로, 더 추상적인 엔티티가 있는 쪽으로만 향한다.
