# Clean Architecture

## 06 세부사항

### 33장 사례 연구: 비디오 판매

#### 제품

> 비디오를 판매하는 소프트웨어로, 판매하길 원하는 비디오들이 있고, 이를 개인과 기업에게 웹을 통해 판매한다. 일반적으로 개인은 시청자인 동시에 구매자며, 기업은 다른 사람들이 시청할 비디오를 구매하는 사람이 따로 있다. 비디오 제작자는 비디오 파일과 비디오에 대한 설명서, 부속 파일을 제공해야 한다. 관리자는 신규 비디오 시리즈물을 추가하거나 기존 시리즈물에 비디오를 추가 또는 삭제하며, 다양한 라이선스에 맞춰 가격을 책정한다.

#### 유스케이스 분석

![유스케이스 분석](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrTeWC%2FbtqCdhqLiAQ%2FWQ0IHFSKFn8IuwUkopAMA1%2Fimg.png)

- 단일 책임 원칙에 따르면 이들 네 액터가 시스템이 변경되어야 할 네 가지 주요 근원이 된다.
  - 신규 기능을 추가하거나 기존 기능을 변경해야 한다면, 그 이유는 반드시 이들 액터 중 하나에게 해당 기능을 제공하기 위해서다.
- 중앙의 점선으로 된 유스케이스는 추상 유스케이스다.
  - 범용적인 정책을 담고 있으며, 다른 유스케이스에서 이를 더 구체화한다.
- 이 추상 유스케이스를 다이어그램에서 없애더라도 전체 제품의 기능을 조금도 손상시키지 않는다.
  - 저자는 두 유스케이스는 너무 비슷하기 때문에, 유사성을 식별해서 분석 초기에 통합하는 방법을 찾는 편이 현명하다고 판단했다.

#### 컴포넌트 아키텍처

![컴포넌트 아키텍처](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcFDjyx%2FbtqCaeWN9kD%2FdJdueROhRdIBmz8s2vIKhk%2Fimg.png)

- 그림에서 이중으로 된 선은 아키텍처 경계를 나타낸다.
- 추상유스케이스로 특수한 컴포넌트인 Catalog View와 Catalog Presenter는 해당 컴포넌트 내부에 추상클래스로 코드화되며 이를 상속받는 컴포넌트는 추상클래스로부터 상속받은 뷰와 프레젠터 클래스를 포함한다.
- 각 컴포넌트는 단일 .jar에 해당할 수 있지만 경계를 구분해서 뷰, 프레젠터, 인터렉트, 컨트롤러, 유틸리티 각각을 하나의 jar로 구분할 수 있다.
  - 또한 뷰와 프레젠터를 같은 .jar에 두고 나머지는 개별로 둘 수 있으며 이처럼 각 컴포넌트들이 독립적으로 컴파일하고 빌드할 수 있는 환경으로 구성되게끔 선택지를 열어두면 시스템이 변경되는 양상에 맞춰 배포방식을 조절할 수 있다.

#### 의존성 관리

- 위 그림에서 제어흐름은 오른쪽에서 왼쪽으로 이동한다.
  - 입력이 컨트롤러에서 발생하면 인터랙터에 의해 처리되어 결과가 만들어지고, 프레젠터가 결과의 포맷을 변경하고 뷰가 화면에 표시한다.
- 아키텍처가 의존성 규칙을 준수하기 때문에 모든 의존성은 항상 더 높은 수준의 정책을 포함하는 컴포넌트로 향한다.
- 사용 관계는 제어흐름과 같은 방향을 가리키며 상속 관계는 제어흐름과는 반대 방향을 가리킨다.

#### 결론

> 아키텍처 다이어그램은 두 가지 서로 다른 차원의 분리 개념을 포함하고 있다. 하나는 단일 책임 원칙에 기반한 액터의 분리이며, 두 번째는 의존성 규칙이다. 이 두 차원은 모두 서로 다른 이유로, 서로 다른 속도로 변경되는 컴포넌트를 분리하는 데 그 목적이 있ㄱ다. 서로 다른 이류라는 것은 액터와 관련이 있으며, 서로 다른 속도라는 것은 정책 수준과 관련이 있다.

> 이런 방식으로 코드를 한 번 구조화하고 나면 시스템을 실제로 배포하는 방식은 다양하게 선택할 수 있게 된다. 상황에 맞게 컴포넌트들을 배포 가능한 단위로 묶을 수도 있고, 상황이 변하면 변한 상황에 맞춰 묶는 단위를 바꾸기도 쉬워진다.
