# Clean Architecture

## 05 아키텍처

### 27장 크고 작은 모든 서비스들

#### 서비스 아키텍처?

- 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다. 아키텍처 관점에서 중요한 서비스도 있지만, 중요하지 않은 서비스도 존재한다.

#### 서비스의 이점?

##### 결합 분리의 오류

- 시스템을 서비스들로 분리함으로써 서비스 사이의 결합이 확실히 분리된다.
  - 모든 서비스 인터페이스가 잘 정의 되어있으며 서비스는 다른 서비스 변수에 직접 접근할 수 없어야 하지만, 이는 환상에 불과하다.
- 하지만 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다.
  - 서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가한다면 이 필드를 사용하는 서비스는 모두 변경되어야한다.
  - 서비스들은 이 필드에 담긴 데이터를 해석하는 방식을 사전에 완벽하게 조율 해야한다.
  - 따라서 서비스들은 데이터 레코드에 강하게 결합되어 서비스들 간에 간접적인 결합이 생긴다.

##### 개발 및 배포 독립성의 오류

- 대규모 엔터프라이즈 시스템을 독립적으로 개발하고 배포 가능한 서비스를 이용하여 만들 수 있다.
- 하지만 서비스 기반 시스템 이외에도 모노리틱, 컴포넌트 기반 등 다른 시스템으로 구축할 수 있기 때문에 서비스는 확장 가능한 시스템을 구축하는 유일한 방법이 아니다.
- 또한 결합 분리의 오류에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포하며, 운영될 수 있는 것은 아니다.

#### 야옹이 문제

![택시 통합 서비스를 구현하기 위해 배치된 서비스들](https://velog.velcdn.com/images/hellojihyoung/post/1a6a8b46-25ba-4c6e-be34-e9a950a0528c/image.png)

- 위의 서비스에 야옹이를 배달하려는 서비스를 추가 하기 위해서는 전부 변경해야 한다.
  - 기능적으로 분해 되어 있기 때문이다.
- 해당 서비스는 모두 결합되어 있기 때문에 독립적으로 개발, 배포, 유지가 불가능하다.

> 이는 바로 횡단 관심사가 지니는 문제이다. 이 서비스와 같은 것처럼 종류의 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에 취약하다.

- 횡단 관심사: 관심사가 여러 객체에 흩어져있는 기능, 관심들

#### 객체가 구출하다

![객체 지향 방식](https://velog.velcdn.com/images/hellojihyoung/post/0cac8ed2-6a92-4cba-ab0c-62eb77e9c88a/image.png)

- 배차 관련 로직은 Rides 컴포넌트에, 야옹이 관련 로직은 Kittens 컴포넌트로 추출되었다.
- 이 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴을 통해 오버라이드 한다.
- 이러한 과정을 통해 야옹이 기능은 결합이 분리되며, 독립적으로 개발, 배포가 가능해진다.
- **템플릿 메소드 패턴**: 전체적으로는 동일하면서 부분적으로는 다른 구문으로 구성된 메서드의 코드 중복을 최소화
- **전략 패턴**: 특정한 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다.
- **의존성 규칙**: 의존성 규칙은 모든 소스코드 의존성은 반드시 외부에서 내부로, 고수준 정책을 향해야 한다

#### 컴포넌트 기반 서비스

- 서비스또한 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수 있어 기존 컴포넌트를 변경하지 않고도 새로운 컴포넌트를 추가할 수 있다.

![컴포넌트 기반 서비스](https://velog.velcdn.com/images/hellojihyoung/post/384621df-d67e-4a2b-9080-d37789a4dd0a/image.png)

- 각 서비스의 자신만의 컴포넌트 설계로 되어있어서 파생 클래스를 만드는 방식으로 야옹이 같은 신규 기능을 추가 할 수 있다.

#### 횡단 관심사

![횡단 관심사](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbht02Y%2FbtqCcWmQxMl%2FVUfXDkyVQkiYI7Y6uqvkIK%2Fimg.png)

- 주요 시스템이 직면하는 횡단 관심사를 처리하기 위해서는 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.
- 아키텍처 경계는 서비스 사이에 존재하지 않으며, 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트다.

#### 결론

> 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다. 시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.

> 서비스는 단 하나의 아키텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있다. 혹은 여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수도 있다. 드물게는 클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을 때도 있다.
