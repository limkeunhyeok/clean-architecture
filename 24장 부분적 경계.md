# Clean Architecture

## 05 아키텍처

### 24장 부분적 경계

#### 마지막 단계를 건너뛰기

> 부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다.

- 부분적 경계를 만들때 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다.
  - 하지만 다수의 컴포넌트를 관리하는 작업은 하지 않아도 된다.
  - 추적을 위한 버전 번호도 없으며, 배포 관리 부담도 없다.
  - 이 차이는 절대 가볍지 않다.

#### 일차원 경계

- 완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 한다.
  - 쌍방향 Boundary 인터페이스 사용한다.

![strategy](https://uchanlee.dev/static/b293659b86da192e720cfebef55a16d6/01267/image-24.1.png)

- 전통적인 전략(Strategy) 패턴을 사용한 전형적인 사례로, ServiceBoundary 인터페이스는 클라이언트가 사용하며 ServiceImpl 클래스가 구현한다.

#### 퍼사드

![facade](https://uchanlee.dev/static/2ef1ddcca1b973ef38074d4056e930a6/a242d/image-24.2.png)

- 이 패턴은 의존성 역전도 희생한다.
- 경계는 Facade 클래스로만 간단히 정의된다.
- Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다.
- 클라이언트는 서비스 클래스에 직접 접근할 수 없다.
- 하지만 이 경우 Client가 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.
- 정적 언어라면 서비스 클래스 중 하나라도 변경되면 Client도 무조건 재컴파일 해야 한다.

#### 결론

> 아키텍처 경계를 부분적으로 구현하는 간단한 방법은 각기 다른 나름의 비용과 장점을 지닌다. 각 접근법은 완벽한 형태의 경계를 담기 위한 공간으로써, 적절하게 사용할 수 있는 상황이 다르다.
